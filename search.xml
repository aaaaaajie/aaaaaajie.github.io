<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>2022年终总结</title>
    <url>/2023/01/19/2022%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<blockquote>
<p>年近将至，今天是壬寅年腊月廿八，公司上的工位已经陆陆续续空了许多，即使还有坚守在岗位上的人儿，其心也不知飞哪里去了，这个人儿也许恰是自己。</p>
</blockquote>
<h2 id="整体进化"><a href="#整体进化" class="headerlink" title="整体进化"></a>整体进化</h2><p>回顾2022，自己也算有些大体的“进化”：<br>✅ 晋升为“合格”前端<br>✅ 晋升为“Wiki”老成员<br>✅ 完成职级晋升</p>
<span id="more"></span>

<h2 id="工作-x2F-业务内容"><a href="#工作-x2F-业务内容" class="headerlink" title="工作&#x2F;业务内容"></a>工作&#x2F;业务内容</h2><p>工作内容上大部分在做 Wiki 业务，编辑器方面<strong>独立</strong>完成了2个较大插件，第三季度参与完成了思维导图的底层开发，后端也参与了些许重构，有时等不及 API 自己也会忍不住整上那么一手。<br>具体的还是要列举几个让自己感觉到充实的功能，也许明年后年或者更久，不会回忆起2022具体做了哪些，希望那时回过头来看看功能是否还依旧“站”得住，可以反馈自己是否成长了。</p>
<h3 id="重构页面权限计算逻辑"><a href="#重构页面权限计算逻辑" class="headerlink" title="重构页面权限计算逻辑"></a>重构页面权限计算逻辑</h3><p>想想 Wiki 的页面权限，内心五味杂陈，如果他能够说话，我定能与他彻夜长谈，因为他是我来 Wiki 的第一个独立负责的模块，当时最有冲劲儿的时刻和精力献给了他，这一路与他相伴，经历了非常的多的挫折，HR 和领导层是 Wiki 的重度用户，至少每个季度绩效考核 HR 都会给各层领导分配所属员工的述职报告，就像每年阿里服务器要面临淘宝的”双十一“，当然可能有点夸张😂 ，这过程产生了很多漏洞，有产品设计上的，也有代码逻辑处理上的，同时还因为其他功能带来的影响也背了黑锅，总的来说功能不小，涉及的点太多，也花费了不少的心思，最后产出了几篇文章和一些讨论（犹豫了下，有可能泄密，链接还是撤回了吧）：</p>
<ul>
<li><a href="https://zhuanlan.zhihu.com/p/465792249">《PingCode Wiki 权限设计之 ACL》</a></li>
<li>《页面权限》</li>
<li>《权限继承方案》</li>
<li>《权限设置-权限点》</li>
<li>《空间所属对权限的补充》</li>
</ul>
<p>这一年 Wiki 加入了空间所属和可见性相关特性，会对之前的权限计算细节有些冲击，加上原有的代码也不是那么好，所以这块是需要重构的，其实当时的现状是 2022 年组内基本不会给我分配服务端方面的工作了，但是最终还是由我负责重构，不为其他，只为遵从内心，保留仅有良心和内心的执着，本着对曾负责的任务励志做到最好。最终的结果还是比较满意，使用比原来更简单了，计算逻辑的细节更清晰了，大大提高了可读性和易用性，同时在部门内发布了一篇文章<a href="https://rc.pcx.cc/g/FNhsAX">《Wiki 权限 v2.0》</a>。</p>
<h3 id="两个插件：关联页面树和文本绘图"><a href="#两个插件：关联页面树和文本绘图" class="headerlink" title="两个插件：关联页面树和文本绘图"></a>两个插件：关联页面树和文本绘图</h3><blockquote>
<p>我去，才回顾了一个功能已经写着么多了……已经下午 1 点了，还没吃饭。</p>
</blockquote>
<p>这两个插件算是较大的功能了，还都挺有成就感的，文本绘图起初说服自己用，自己写的功能自己不用还靠别人用吗？现在已经爱了爱了。当时也分享一篇文章<a href="https://rc.pcx.cc/g/fqKr0x">《文本绘图实现》</a>，页面树是自己从头到尾独立负责的插件，标志着一个里程碑，仅此而已，难点只有一个还是涉及权限的一些交互。</p>
<h3 id="参与思维导图"><a href="#参与思维导图" class="headerlink" title="参与思维导图"></a>参与思维导图</h3><p>满足了一直憧憬着的编辑器底层技术，参与思维导图时有些许的激动，但这过程中是有些煎熬和烧脑的，每天都是超负荷，不得不吐槽一下：工期短，任务重，要求陌生的领域要像普通业务一样的开发进度，这谁能顶得住啊？底层还涉及到一些数学知识和算法。不过也都过去了，痛并快乐着，哦，值得一记的功能点是拖拽节点的占位显示，已经上线的方案很鸡肋，新方案已确定，只是还没有狠下心来花时间去落实。</p>
<h2 id="阅读和知识分享"><a href="#阅读和知识分享" class="headerlink" title="阅读和知识分享"></a>阅读和知识分享</h2><p>✅ 每日一学 15 篇<br>✅ 向 WTC 供稿 2 篇<br>✅ 技术周刊 2 篇<br>✅ 技术分享 2 次<br>✅ 知乎发布《RxJS 全面解析》点赞至今 81 个，还挺激动的<br>✅ 《RxJS 深入浅出》—— 程墨<br>✅ 《沧浪之水》还挺有感触的<br>✅ 其他乱七八糟的书都翻一翻，都没读太完整…<br>总体上这方面还行，有些沉淀，也提升了一下写作能力。</p>
<h2 id="沉淀技术"><a href="#沉淀技术" class="headerlink" title="沉淀技术"></a>沉淀技术</h2><p>✅ 使用 Angular 可以完成大多数业务<br>✅ 深度理解 RxJS，但对很多操作符还不够熟悉</p>
<h2 id="心态"><a href="#心态" class="headerlink" title="心态"></a>心态</h2><p>整体来说，不再那么浮躁，沉稳了许多，可能是经历多了些，也有可能是多看了几本书，提升了认知，看明白了一些事情，对任务量做了减法，对完成度和质量做了加法，这点小组组长不一定认可，不过无所谓了。绩效上也不再过度追求，不再那么逼着自己上进学习或者说卷，这样反而内心少了许多焦虑，毕竟不在乎就不会难受了，这也可能是消极，随之快乐也减少了，想想也许有时糊涂比明白更好。</p>
<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p>一个字，“懒”。自制力差一直是问题。<br>还有二个字，“胆怯”，对自己不擅长的东西和不太好把握的东西，还不是那么够勇敢，会想着退缩，不管是工作还是生活。</p>
<h2 id="明年规划"><a href="#明年规划" class="headerlink" title="明年规划"></a>明年规划</h2><p>再沉淀一门前端技术，沉淀几篇有深度的文章，今年 RxJS 这块还是比较满意的，也许来年再加深一些！</p>
<hr>
<blockquote>
<p>下午 1 点 55 了，终于写完了，这篇是个人总结也是一篇内心日记，下午说是要写对联，摸摸鱼，明日启程回家，来年再战🧨</p>
</blockquote>
]]></content>
      <categories>
        <category>年终总结</category>
      </categories>
  </entry>
  <entry>
    <title>RxJS “道” 与 “术”</title>
    <url>/2023/01/19/RxJS%E9%81%93%E4%B8%8E%E6%9C%AF/</url>
    <content><![CDATA[<blockquote>
<p>首发于<a href="https://zhuanlan.zhihu.com/p/583539989">知乎 PingCode 专栏</a>。</p>
</blockquote>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>打开此文的小伙伴想必对 RxJS 已经有了或多或少的了解，如果没有倒也无妨，因为下面会从零开始讲起；如果你带着几个问题来翻阅，本人也希望此文可以带你找到答案。</p>
<p>温馨提示：文章内容较长，建议收藏反复观看。</p>
<span id="more"></span>



<h1 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h1><p>从我个人的学习 RxJS 的历程来看，最开始是“照猫画虎”能够基本使用，随后是研究部分操作符和使用场景，最后了解产生背景、设计思想以及实现原理。在这期间有过很多疑问，也曾从不同角度理解 RxJS，最终总结了认为比较系统的知识图谱（下图）。</p>
<p><img src="https://atlas-rc.pingcode.com/files/public/6334fa685a7447c844d806c4/origin-url" alt="image.png"></p>
<h1 id="深入理解-RxJS"><a href="#深入理解-RxJS" class="headerlink" title="深入理解 RxJS"></a>深入理解 RxJS</h1><h2 id="大“道”——响应式编程"><a href="#大“道”——响应式编程" class="headerlink" title="大“道”——响应式编程"></a>大“道”——响应式编程</h2><p>全面理解一个事物，追溯其历史是一种好的方式，RxJS 的起源需要追溯到  <strong>响应式编程（RP）</strong>  ，后续发展了一系列基于响应式编程范式的语言扩展（Rx，RxJS 就是其中之一），请看历史简谱（左向右延续）。</p>
<p><img src="https://atlas-rc.pingcode.com/files/public/631a8fa22ce1c1a732e1147d/origin-url" alt="image.png"></p>
<h3 id="何为响应式"><a href="#何为响应式" class="headerlink" title="何为响应式"></a>何为响应式</h3><blockquote>
<p>响应式是学习 RxJS 必须要理解的概念，本人用了大量的文字来解释，如果您已经深刻理解，可直接跳过。如果您是第一次接触这个名词，也不要先给自己心里暗示它有多么的高深和难以理解，也许你天天在使用。</p>
</blockquote>
<h4 id="一个例子"><a href="#一个例子" class="headerlink" title="一个例子"></a>一个例子</h4><p>为了避免上来就接触晦涩的概念，先来举个例子：  <strong>博客平台关注功能</strong>  。话说你偶然浏览到阿杰的文章，觉得写的很赞，于是你  <strong>关注</strong>  了他的博客账号，以便不会错过之后的干货，在以后的日子里阿杰  <strong>每发布一篇文章博客平台都会给你推送一条消息</strong>  ，提醒你来给他点点赞，假设博客平台没有关注的功能，那么你需要想知道他的最新动态就只能打开他的个人主页查看文章列表来确认，也许稍不留意就会错过他的文章。这个例子出现了  <strong>粉丝关注博主、博主发布博客、平台自动推送给粉丝消息、给文章点赞</strong>  ，这就形成了响应式闭环，平台在观察到博主粉丝只需要关注一下就能收到博主以后的动态，这就是响应式带来的好处。</p>
<h4 id="另一个例子"><a href="#另一个例子" class="headerlink" title="另一个例子"></a>另一个例子</h4><p>再举一个贴近我们开发的例子：假设有一个更新某用户密码的需求，A 同事负责调用更新逻辑并在更新后执行其他任务（比如提醒用户更新成功或失败），B 同事负责具体更新密码的逻辑，下图描述了完成整个任务的流程：</p>
<p><img src="https://atlas-rc.pingcode.com/files/public/6309ab9951ba5c30098e82c6/origin-url" alt="image.png"></p>
<p>实际情况更新逻辑比较复杂，有以下逻辑：</p>
<ol>
<li>验证一下用户信息的真实性 </li>
<li>验证密码是否合法</li>
<li>最终把新的密码入库</li>
</ol>
<p>上述的每个环节都有可能是异步耗时任务，比如用户的真实性是第三方平台验证的，入库的过程中网络非常慢，再比如……等等，诸如此类的各种不确定性，这对于 B 同事做后续任务就有了一个关键性条件，  <strong>确定&#x2F;等待更新结果</strong>  ，这种情况有一种做法是：定期轮询重试，B 每隔一段时间执行一次，直到确定 A 已经修改成功，再去执行后续操作。逻辑中定时 A 逻辑结束这种做法明显有一个弊端是执行多次，对于 B 显然不是好的做法，好的做法是：  <strong>B 的更新逻辑执行完后通知 A，</strong>  甚至 B 可以先把更新后的事准备好，让 A 决定后续逻辑的执行时机。</p>
<p><img src="https://atlas-rc.pingcode.com/files/public/6309ac7651ba5c30098e82c7/origin-url" alt="image.png"></p>
<p>流程如图示：  <strong>订阅&#x2F;执行更新逻辑、更新逻辑结束、将结果通知调用者、执行后续逻辑</strong>  。这就是响应式的做法，它带来的好处是  <strong>：当更新结果发生变化时自动通知调用者，而不用轮询重试</strong>  。</p>
<h3 id="了解响应式宣言"><a href="#了解响应式宣言" class="headerlink" title="了解响应式宣言"></a>了解响应式宣言</h3><p>相信你已经明白了响应式，并能发现生活&#x2F;工作中到处可见，下面了解一下设计响应式模块&#x2F;系统遵循的原则：</p>
<ul>
<li>即时响应性：只要有可能，就要及时地做出响应。</li>
<li>回弹性  <strong>：</strong>  执行过程中在出现失败时依然保持即时响应性。</li>
<li>弹性  <strong>：</strong>   在不断变化的工作负载之下依然保持即时响应性。</li>
<li>消息驱动  <strong>：</strong>  反应式依赖异步的消息传递，从而确保了松耦合、隔离、位置透明的组件之间有着明确边界。</li>
</ul>
<p><img src="https://atlas-rc.pingcode.com/files/public/6332abe95a7447c844d804b3/origin-url" alt="image.png"></p>
<h3 id="响应式编程"><a href="#响应式编程" class="headerlink" title="响应式编程"></a>响应式编程</h3><p>下面我们正式的介绍响应式编程：</p>
<p><strong>响应式编程，</strong>  Reactive Programing，又称反应式编程  <strong>，</strong>  简称 RP，是一种以传播数据流（数据流概念戳  <a href="https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E6%B5%81/3002243">这里</a>   ）的编程范式。</p>
<blockquote>
<p><strong>响应式编程</strong>  或  <strong>反应式编程</strong>  （英语：Reactive programming）是一种面向数据流和变化传播的声明式编程范式。这意味着可以在编程语言中很方便地表达静态或动态的数据流，而相关的计算模型会自动将变化的值通过数据流进行传播。                                                                                                                 —— 维基百科</p>
</blockquote>
<p>优势：</p>
<ol>
<li><strong>声明式</strong>  ，方便地表达静态或动态的数据流</li>
<li><strong>自动化</strong>  ，自动将变化的值通过数据流进行传播</li>
</ol>
<p><strong>核心思想：</strong>  从传统的调用方“拉”数据的思维模式转变为被调用方“推”数据的思维模式。</p>
<h3 id="JS-异步编程史"><a href="#JS-异步编程史" class="headerlink" title="JS 异步编程史"></a>JS 异步编程史</h3><blockquote>
<p>众所周知，JS 执行环境是单线程的，在事件监听，异步的处理，响应式编程毋庸置疑是其中一大主力。</p>
</blockquote>
<h4 id="Callback-时代"><a href="#Callback-时代" class="headerlink" title="Callback 时代"></a>Callback 时代</h4><p>回调函数延续至今，JS 的运用高阶函数巧妙地将异步后的逻辑进行托管，以  <strong>事件驱动</strong>  的方式来解决异步编程，但它有一个“臭名昭著”的问题：  <strong>回调嵌套</strong>  ，耦合度高。本来很简单的逻辑但为了控制执行流程却不得不写大量的代码，当时产生了一些知名的库：async、bluebrid，它们封装和处理了嵌套问题，暴露出更为简单好用的 API，额外还可以优雅地处理流程控制相关场景，但所做的只是划分了逻辑，依旧没有解决代码臃肿的问题。</p>
<h4 id="Promise-时代"><a href="#Promise-时代" class="headerlink" title="Promise 时代"></a>Promise 时代</h4><p>ES6 纳入 Promise 之后可谓一大喜讯，因为它解决了回调嵌套的问题，虽然它只是回调的语法糖，但在处理流程和捕获错误（外层处理）已经非常的优雅了，但它的弊端是：  <strong>无法监听和打断 Promise 的状态</strong>  。这意味着一旦声明它会立即执行并修改它的执行状态，这源于它的实现。</p>
<h4 id="Generator"><a href="#Generator" class="headerlink" title="Generator"></a>Generator</h4><p>Generator 是处于 Promise 和 Async&#x2F;await 之间的产物，它给我们带来了写异步语法像写同步一般，只需在函数前加  <code>*</code>  修饰，这样就可以在函数内部使用一个   <code>yield</code>  关键字返回结果，类似于   <code>await</code>  ，但它也并非完美，不然也不会有后面的 Async&#x2F;await 了，它的主要问题是  <strong>流程管理不方便（迭代器模式实现，主动调 next 执行器流转游标）。</strong></p>
<h4 id="Async-x2F-await"><a href="#Async-x2F-await" class="headerlink" title="Async&#x2F;await"></a>Async&#x2F;await</h4><p>Async&#x2F;await 是 Generator 语法糖，既保留了语法上的优势，也解决了 Generator 每步要调一下 next 执行器的弊端，是现阶段的最佳方案，就是得吐槽一下 Top-level await 到 ES2022  才出现。</p>
<p><strong>其中 Generator 和 Async&#x2F;await 在异步编程是以等待的方式处理。</strong></p>
<h3 id="ReactiveX"><a href="#ReactiveX" class="headerlink" title="ReactiveX"></a>ReactiveX</h3><blockquote>
<p>业界一致认为正统的响应式实现&#x2F;扩展是 ReactiveX 系列。</p>
</blockquote>
<p>ReactiveX，简称 Rx，是基于响应式的扩展，是各种语言实现的一个统称，除了我们所知道的 RxJS，还有 RxJava、Rx.NET、RxKotlin、RxPHP…..它最早是由微软提出并引入到 .NET 平台中，随后 ES6 也引入了类似的技术。</p>
<p>它扩展了观察者模式，以支持数据序列和&#x2F;或事件，并添加了操作符，允许您以声明的方式将序列组合在一起，同时  <strong>抽象出诸如低级线程、同步、线程安全、并发数据结构和非阻塞I&#x2F;O等问题。</strong></p>
<h3 id="RxJS"><a href="#RxJS" class="headerlink" title="RxJS"></a>RxJS</h3><p>RxJS 全称 Reactive Extensions for JavaScript，翻译过来是 Javascript 的响应式扩展，它是一个采用流来处理异步和事件的工具库，简单来说   <strong>Rx(JS) &#x3D; Observables + Operator + Scheduler</strong>  。</p>
<h4 id="擅长做的事"><a href="#擅长做的事" class="headerlink" title="擅长做的事"></a>擅长做的事</h4><ul>
<li>UI 事件：例如鼠标移动、按钮单击……</li>
<li>状态管理：例如属性更改、集合更新等事件</li>
<li>IO 消息事件：服务监听</li>
<li>广播&#x2F;通知：消息总线（Event bus）</li>
<li>网络消息&#x2F;事件：例如 HTTP、WebSockets API 或其他低延迟中间件</li>
</ul>
<p>最大的优势：  异步事件的抽象，这意味着可以把很多事统一起来当作一种方式处理，从而让问题变得更简单，同时也降低了学习成本。</p>
<p>注意：RxJS 擅长做异步的事，不代表不可以做同步或不擅长同步的事。</p>
<h3 id="RxJS-在-Angular-中的应用"><a href="#RxJS-在-Angular-中的应用" class="headerlink" title="RxJS 在 Angular 中的应用"></a>RxJS 在 Angular 中的应用</h3><p>RxJS 在 Angular 中及其重要，很多核心模块都是由 RxJS 实现的，比如：</p>
<ul>
<li>响应式表单</li>
<li>路由</li>
<li>HttpClient（封装的 ajax，类似于 axios）</li>
<li>async 管道符</li>
<li>状态管理</li>
</ul>
<p>更多：  <a href="https://angular.io/guide/observables-in-angular">https://angular.io/guide/observables-in-angular</a>  </p>
<h1 id="RxJS-核心概念——-Observables"><a href="#RxJS-核心概念——-Observables" class="headerlink" title="RxJS 核心概念—— Observables"></a>RxJS 核心概念—— Observables</h1><p><img src="https://atlas-rc.pingcode.com/files/public/6332cf215a7447c844d8051c/origin-url" alt="image.png"></p>
<p>RxJS 中的 Observables 系列是围绕观察者模式来实现的，基本角色：</p>
<ol>
<li>Observable：被观察者，用来产生消息&#x2F;数据。</li>
<li>Observer：观察者，用来消费消息&#x2F;数据。</li>
</ol>
<h2 id="Observable"><a href="#Observable" class="headerlink" title="Observable"></a>Observable</h2><p>Observeable 是观察者模式中的被观察者，它维护一段执行函数，提供了  <strong>惰性执行的能力</strong>  （subscribe）。</p>
<h3 id="核心函数"><a href="#核心函数" class="headerlink" title="核心函数"></a><strong>核心函数</strong></h3><ul>
<li>constructor(_subscribe) : 创建 Observeable</li>
<li>static create(_subscribe)：静态函数创建 Observeable</li>
<li>pipe()：管道</li>
<li>subscribe()：执行初始化传入的 _subscribe</li>
</ul>
<blockquote>
<p>RxJS 中 Observeable 是一等公民，将一切问题都转化为 Observable 去处理。转换的操作符有   <code>from</code>  、  <code>fromEvent</code>  、  <code>of</code>  、  <code>timer</code>  等等，更多戳  <a href="https://cn.rx.js.org/manual/overview.html#h39">这里。</a>    注意的是：只有   <a href="https://cn.rx.js.org/class/es6/MiscJSDoc.js~ObservableInputDoc.html">ObservableInput</a>   或   <a href="https://cn.rx.js.org/class/es6/MiscJSDoc.js~SubscribableOrPromiseDoc.html">SubscribableOrPromise</a>   类型的值才可以转化为 Observable。</p>
</blockquote>
<h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><p><img src="https://atlas-rc.pingcode.com/files/public/631ad4c12ce1c1a732e114df/origin-url" alt="image.png"></p>
<h3 id="源码实现"><a href="#源码实现" class="headerlink" title="源码实现"></a>源码实现</h3><p>本人写（抽取）了一套 RxJS Observable 源码中的核心实现</p>
<p><img src="https://atlas-rc.pingcode.com/files/public/631af91f2ce1c1a732e11520/origin-url" alt="image.png"></p>
<h2 id="Observable-与-Promise"><a href="#Observable-与-Promise" class="headerlink" title="Observable 与 Promise"></a>Observable 与 Promise</h2><blockquote>
<p>用过两者的同学可能会有疑问为什么采用 Observable 而不直接用 Promise 或 Async&#x2F;await，这两者在业界也常常用来做对比。</p>
</blockquote>
<p>它们关键性的不同点：</p>
<table>
<thead>
<tr>
<th></th>
<th>Observable</th>
<th>Promise</th>
</tr>
</thead>
<tbody><tr>
<td>使用场景</td>
<td>同步、异步均可使用</td>
<td>用 Promise 包裹的多数是异步场景</td>
</tr>
<tr>
<td>执行时机</td>
<td>声明式惰性执行，只有在订阅后才会执行</td>
<td>创建时就立即执行</td>
</tr>
<tr>
<td>执行次数</td>
<td>多次调用 subscribe 函数会执行多次</td>
<td>只有第一次执行，后续都是取值</td>
</tr>
<tr>
<td>流程控制</td>
<td>相较于 Promise 有更为全面的操作符</td>
<td>提供串行、并行的函数</td>
</tr>
<tr>
<td>错误处理</td>
<td>subscribe 函数捕获错误</td>
<td>.catch 捕获</td>
</tr>
</tbody></table>
<p>总的来说，  <strong>Promise 可读性更优，Observable 从使用场景更为全面</strong>  。</p>
<h3 id="两者的相互转换"><a href="#两者的相互转换" class="headerlink" title="两者的相互转换"></a>两者的相互转换</h3><p>在既使用了 RxJS 又引用了用 Promise 封装的库时，两者相互转换是容易碰到的问题，RxJS 提供了两者转换的函数。</p>
<h4 id="Promise-转-Observable"><a href="#Promise-转-Observable" class="headerlink" title="Promise 转 Observable"></a><strong>Promise 转 Observable</strong></h4><p>from 或 fromPromise（弃用） 操作符</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const observable$ = from(fetch(&#x27;http://xxx.com/&#x27;));</span><br></pre></td></tr></table></figure>

<h4 id="Observable-转-Promise"><a href="#Observable-转-Promise" class="headerlink" title="Observable 转 Promise"></a><strong>Observable 转 Promise</strong></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const promise = of(42).toPromise();</span><br><span class="line">const errorPromise = throw(new Error(&#x27;woops&#x27;)).toPromise();</span><br><span class="line">errorPromise.catch(err=&gt; console.error);</span><br></pre></td></tr></table></figure>



<h2 id="Subscriber-x2F-Observer"><a href="#Subscriber-x2F-Observer" class="headerlink" title="Subscriber&#x2F;Observer"></a>Subscriber&#x2F;Observer</h2><p>Subscriber&#x2F;Observer 是观察者模式中的观察者&#x2F;消费者，它用来消费&#x2F;执行 Observable 创建的函数。</p>
<h3 id="核心能力"><a href="#核心能力" class="headerlink" title="核心能力"></a><strong>核心能力</strong></h3><ol>
<li><code>next</code>  （传值）</li>
<li><code>error</code>  （错误处理）</li>
<li><code>complete</code>  （完成&#x2F;终止）</li>
<li><img src="https://atlas-rc.pingcode.com/files/public/631b066a2ce1c1a732e1158f/origin-url" alt="image.png"></li>
</ol>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p><img src="https://atlas-rc.pingcode.com/files/public/631b065a2ce1c1a732e1158e/origin-url" alt="image.png"></p>
<p><img src="https://atlas-rc.pingcode.com/files/public/631b07082ce1c1a732e11590/origin-url" alt="image.png"></p>
<p>白话描述：</p>
<ol>
<li>将 subscribe 传进去一个 next 函数赋给 Observer 的 next 函数。</li>
<li>将 Observer 传给 Observable 初始化的预加载函数 _subscribe。</li>
<li>执行 Observable 初始化的预加载函数</li>
</ol>
<h3 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h3><p><img src="https://atlas-rc.pingcode.com/files/public/630364d1aae45a607c402e62/origin-url" alt="image.png"></p>
<h2 id="Subscription"><a href="#Subscription" class="headerlink" title="Subscription"></a>Subscription</h2><p>上面的 Observable 和 Observer 已经完成了观察者模式的核心能力，但是引发的一个问题是，每次执行一个流创建一个 Observable，这可能会创建多个对象（尤其是大量使用操作符时，会创建多个 Observable 对象，这个我们后面再说），此时需要外部去销毁此对象，不然会造成内存泄露。</p>
<p>为了解决这个问题，所以产生了一个   <strong>Subscription</strong>   的对象，Subscription 是表示可清理资源的对象，它是由 Observable 执行之后产生的。</p>
<h3 id="核心能力-1"><a href="#核心能力-1" class="headerlink" title="核心能力"></a>核心能力</h3><ol>
<li><code>unsubcribe</code>  （取消订阅）</li>
<li><code>add</code>  （分组或在取消订阅之前插入一段逻辑）</li>
</ol>
<p><img src="https://atlas-rc.pingcode.com/files/public/631b0bd12ce1c1a732e115b4/origin-url" alt="image.png"></p>
<p>注意：调用  <code>unsubcribe</code>  后（包含  <code>add</code>  传入的其它 Subscription）不会再接收到它们的数据。</p>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p><img src="https://atlas-rc.pingcode.com/files/public/631b0b9c2ce1c1a732e115b3/origin-url" alt="image.png"></p>
<h3 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h3><p><img src="https://atlas-rc.pingcode.com/files/public/631b0c332ce1c1a732e115b7/origin-url" alt="image.png"></p>
<p><img src="https://atlas-rc.pingcode.com/files/public/631b0c0e2ce1c1a732e115b6/origin-url" alt="image.png"></p>
<p>白话描述：</p>
<ol>
<li>调用 Observable 的 subscribe 后会添加（add 方法）到 Subscription（这里有个关系 Subscriber 继承了 Subscription） 中，并把 Subscriber（也是 Subscription）返出去。</li>
<li>调用 Subscription 的 unsubscribe 方法。</li>
<li>unsubscribe 把该对象置空回收。</li>
</ol>
<h3 id="完整工作流程"><a href="#完整工作流程" class="headerlink" title="完整工作流程"></a>完整工作流程</h3><p><img src="https://atlas-rc.pingcode.com/files/public/63036b23aae45a607c402e67/origin-url" alt="image.png"></p>
<h2 id="Subject"><a href="#Subject" class="headerlink" title="Subject"></a>Subject</h2><p>上述的 Observable 归根到底就是一个惰性执行的过程，当遇到以下两种情况就显得偏弱：</p>
<ol>
<li><strong>推送多条数据时，需要就要创建多个对象。</strong></li>
<li><strong>做状态管理或消息通讯，监听数据变化并实时推送。</strong></li>
</ol>
<p>基于这两个方面，所以产生了 Subject，Subject 是一个特殊的 Observable，更像一个 EventEmitter，它既可以是被观察者&#x2F;生产者也可以是观察者&#x2F;消费者。</p>
<h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a><strong>优势</strong></h3><ol>
<li>减少开销和提高性能</li>
<li>数据实时推送</li>
</ol>
<h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a><strong>场景</strong></h3><p>消息传递或广播。</p>
<h3 id="与-Observable-的区别"><a href="#与-Observable-的区别" class="headerlink" title="与 Observable 的区别"></a>与 Observable 的区别</h3><table>
<thead>
<tr>
<th></th>
<th>Observable</th>
<th>Subject</th>
</tr>
</thead>
<tbody><tr>
<td>角色</td>
<td>生产者（单向）</td>
<td>生产者、消费者（双向）</td>
</tr>
<tr>
<td>消费策略</td>
<td>单播</td>
<td>多播</td>
</tr>
<tr>
<td>流转方式</td>
<td>内部发送&#x2F;接收数据</td>
<td>外部发送&#x2F;接收数据</td>
</tr>
<tr>
<td>数据特性</td>
<td>冷数据流</td>
<td>热数据流</td>
</tr>
<tr>
<td>消费时机</td>
<td>调用 subscribe</td>
<td>调用 next</td>
</tr>
</tbody></table>
<p>重点解释一下消费策略和消费时机两块：</p>
<p><strong>冷数据流：</strong>  可以订阅任意时间的数据流。</p>
<p><strong>热数据流</strong>  ：只给已订阅的消费者发送消息，定阅之前的消费者，不会收到消息。</p>
<p>用一个示例来演示：</p>
<p><img src="https://atlas-rc.pingcode.com/files/public/631b19f42ce1c1a732e115cc/origin-url" alt="image.png"></p>
<h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><p><img src="https://atlas-rc.pingcode.com/files/public/62e9e3d394d1376ff02bb5c7/origin-url" alt="image.png"></p>
<p>PS：忘记了该图出自哪篇文章，画的挺不错的，这里直接引用了，如有侵权，还望联系作者。</p>
<h3 id="源码实现-1"><a href="#源码实现-1" class="headerlink" title="源码实现"></a>源码实现</h3><ul>
<li>observers 订阅者集合</li>
<li>_subscribe 添加订阅者</li>
<li>next 函数将所有订阅者推送相同的数据</li>
</ul>
<p><img src="https://atlas-rc.pingcode.com/files/public/63317ad05a7447c844d803d6/origin-url" alt="image.png"></p>
<h3 id="其他-Subject"><a href="#其他-Subject" class="headerlink" title="其他 Subject"></a>其他 Subject</h3><table>
<thead>
<tr>
<th>种类</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td><code>BehaviorSubject</code></td>
<td>回放数据，如果是订阅前推送的数据，只回放最新的值</td>
</tr>
<tr>
<td><code>ReplaySubject</code></td>
<td>回放数据，初始化设定要缓存多少次的值，然后将这批消息推送</td>
</tr>
<tr>
<td><code>AsyncSubject</code></td>
<td>只有调用 complete 后才会推送数据</td>
</tr>
</tbody></table>
<h1 id="操作符（Operator）"><a href="#操作符（Operator）" class="headerlink" title="操作符（Operator）"></a>操作符（Operator）</h1><blockquote>
<p>由于篇幅问题，本节并不会细化到讲每个操作符</p>
</blockquote>
<h2 id="理解操作符"><a href="#理解操作符" class="headerlink" title="理解操作符"></a>理解操作符</h2><p>Operator 本质上是一个纯函数 (pure function)，  <strong>它接收一个 Observable 作为输入，并生成一个新的 Observable 作为输出。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export interface Operator&lt;T, R&gt; &#123;</span><br><span class="line">  call(subscriber: Subscriber&lt;R&gt;, source: any): TeardownLogic;</span><br><span class="line">&#125;</span><br><span class="line">// 等价于</span><br><span class="line">function Operator(subscriber: Subscriber&lt;R&gt;, source: any)&#123;&#125;</span><br></pre></td></tr></table></figure>

<h2 id="遵循的小道"><a href="#遵循的小道" class="headerlink" title="遵循的小道"></a>遵循的小道</h2><p>迭代器模式和集合的函数式编程模式以及管道思想（pipeable）</p>
<h3 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h3><p>操作符的实现以及使用均依照函数式的编程范式，Functional Programing，简称 FP，函数式编程范式，它的思维就是一切用函数表达和解决问题，避免用命令式。</p>
<p>优点：</p>
<ul>
<li>链式调用&#x2F;组合开发</li>
<li>简单易写易读（声明式）</li>
<li>可靠性（纯函数不存在依赖）</li>
<li>惰性求值（高阶函数）</li>
<li>易于测试</li>
</ul>
<p>更多详细看这篇  <a href="https://pingcode.com/pages/taOxc8Afhg#%20%E3%80%8A%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E3%80%8B">不完全指南🧭</a>  </p>
<h3 id="pipe"><a href="#pipe" class="headerlink" title="pipe"></a>pipe</h3><p>管道，用来承载数据流的容器，相信大家一定用过 Lodash 的chain，原生 js 数组，NodeJS 开发者 也许还知道 async&#x2F;bluebird 的 waterfall，Mongodb 的 pipe，它们都遵循管道思想，最直接的好处是  链式调用  ，还可以用来  划分逻辑  ，在异步的场景中还可以做流程控制（串行、并行、竞速等等）。</p>
<h2 id="为什么要有操作符？"><a href="#为什么要有操作符？" class="headerlink" title="为什么要有操作符？"></a>为什么要有操作符？</h2><p>遵循符合响应式宣言，单向线性的通讯或传输数据，pipe 可以  降低耦合度以便于阅读和维护  ，把复杂的问题分解成多个简单的问题，最后在组合起来。</p>
<h2 id="操作符与数据流"><a href="#操作符与数据流" class="headerlink" title="操作符与数据流"></a>操作符与数据流</h2><p>在 RxJS 的世界解决问题的方式是抽象为数据流，整个闭环是围绕数据流进行的，所以我们再来理解一下数据流：流，可以把数据可以想像成现实中的水流，河流，流有上游、下游每个阶段处理不同的事情，在这过程避免不了要操作流，比如合并、流程控制、频率控制等等，所以操作符就扮演了此角色。</p>
<p>生命周期：创建流（create、new、创建类操作符）——&gt; 执行流（subscribe） ——&gt; 销毁流（unsubscribe）</p>
<h2 id=""><a href="#" class="headerlink" title=""></a></h2><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><p><img src="https://atlas-rc.pingcode.com/files/public/62ff2e90da981d95b9627cd4/origin-url" alt="image.png"></p>
<h2 id="工作原理-1"><a href="#工作原理-1" class="headerlink" title="工作原理"></a>工作原理</h2><p>迭代器模式：当多个操作符时，组合成多个可迭代对象的集合，执行时依次调用 next 函数。</p>
<p><img src="https://atlas-rc.pingcode.com/files/public/630488acaae45a607c402f2b/origin-url" alt="image.png"></p>
<h2 id="源码实现-2"><a href="#源码实现-2" class="headerlink" title="源码实现"></a>源码实现</h2><ol>
<li>操作符传入 pipe</li>
<li>pipe 将操作符转换成可迭代的 Array</li>
<li>subscribe（执行流）时消费操作符逻辑</li>
</ol>
<p>如图</p>
<p><img src="https://atlas-rc.pingcode.com/files/public/633172935a7447c844d803c7/origin-url" alt="image.png"></p>
<p>操作符转换 Array 源码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export function pipeFromArray(fns: Array&lt;Function&gt;): Function &#123;</span><br><span class="line">    if (fns.length === 0) &#123;</span><br><span class="line">        return (x: any) =&gt; x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (fns.length === 1) &#123;</span><br><span class="line">        return fns[0];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return (input: any) =&gt; &#123;</span><br><span class="line">        return fns.reduce((prev: any, fn: Function) =&gt; fn(prev), input);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="创建自定义操作符"><a href="#创建自定义操作符" class="headerlink" title="创建自定义操作符"></a>创建自定义操作符</h2><h3 id="方式一"><a href="#方式一" class="headerlink" title="方式一"></a>方式一</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const isEven = () =&gt; &#123;</span><br><span class="line">    return (source: Observable&lt;any&gt;) =&gt; &#123;</span><br><span class="line">        return new Observable&lt;any&gt;(observer =&gt; &#123;</span><br><span class="line">            const subscription = source.subscribe((x) =&gt; &#123;</span><br><span class="line">                observer.next(x % 2 === 0);</span><br><span class="line">                observer.complete();</span><br><span class="line">            &#125;)</span><br><span class="line">            return () =&gt; subscription.unsubscribe();</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">new Observable(observer =&gt; &#123;</span><br><span class="line">    observer.next(7);</span><br><span class="line">&#125;)</span><br><span class="line">    .pipe(isEven())</span><br><span class="line">    .subscribe(console.log);</span><br><span class="line">// 执行结果：false</span><br></pre></td></tr></table></figure>

<h3 id="方式二：基于-lift"><a href="#方式二：基于-lift" class="headerlink" title="方式二：基于 lift"></a>方式二：基于 lift</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const odd = () =&gt; &#123;</span><br><span class="line">    const operator: Operator&lt;any, any&gt; = &#123;</span><br><span class="line">        call(subscriber: Subscriber&lt;any&gt;, source: any) &#123;</span><br><span class="line">            const subscription = source.subscribe((x: any) =&gt; subscriber.next(x % 2 !== 0));</span><br><span class="line">            return () =&gt; &#123;</span><br><span class="line">                subscription.unsubscribe();</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">    return operator;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">new Observable(observer =&gt; &#123;</span><br><span class="line">    observer.next(7);</span><br><span class="line">&#125;)</span><br><span class="line">    .lift(odd())</span><br><span class="line">    .subscribe(console.log)</span><br><span class="line">// 执行结果 true</span><br></pre></td></tr></table></figure>

<h4 id="lift-源码"><a href="#lift-源码" class="headerlink" title="lift 源码"></a>lift 源码</h4><p><img src="https://atlas-rc.pingcode.com/files/public/6331747e5a7447c844d803cb/origin-url" alt="image.png"></p>
<h2 id="阅读弹珠-x2F-大理石图"><a href="#阅读弹珠-x2F-大理石图" class="headerlink" title="阅读弹珠&#x2F;大理石图"></a>阅读弹珠&#x2F;大理石图</h2><p>学会阅读弹珠图是快速理解 Rx 操作符的手段之一，有些操作符需要描述时间流逝以及序列，所以弹珠图有很多的标识和符号，如下图。</p>
<p><img src="https://atlas-rc.pingcode.com/files/public/6333b44c5a7447c844d805a9/origin-url" alt="image.png"></p>
<p>这里有几个用来理解大理石图的网站：</p>
<ul>
<li><a href="https://rxviz.com/">https://rxviz.com/</a>  </li>
<li><a href="https://rxmarbles.com/">https://rxmarbles.com/</a></li>
</ul>
<h2 id="学习参考"><a href="#学习参考" class="headerlink" title="学习参考"></a>学习参考</h2><ul>
<li>Async.js</li>
<li>Lodash</li>
</ul>
<h1 id="调度器（Scheduler）"><a href="#调度器（Scheduler）" class="headerlink" title="调度器（Scheduler）"></a>调度器（Scheduler）</h1><h2 id="何为调度器"><a href="#何为调度器" class="headerlink" title="何为调度器"></a>何为调度器</h2><blockquote>
<p>也许你在使用操作符的过程中从未在意过它，但它在 Rx 起着至关重要的作用，在异步中如何调度异步任务是很复杂的事情（尤其是以线程为核心处理异步任务的语言），很庆幸的是我们用使用的 JS ，所以不需要过多的关注线程问题，更友好的是大多数操作符默认帮开发者选中了合适的调度模式（下文会讲到），以至于我们从忽略了它，但无论如何我们都应该对调度器有基本的了解。</p>
</blockquote>
<p>调度器，  <code>**Scheduler**</code>  ** 用来控制数据推送节奏的**  ，RxJS 有自己的基准时钟和一套的执行规则，来安排多个任务&#x2F;数据该如何执行  。</p>
<p>官方定义：</p>
<ul>
<li>Scheduler 是一种数据结构</li>
<li>Scheduler 是一个执行环境</li>
<li>Scheduler 是一个虚拟时钟</li>
</ul>
<h2 id="种类-x2F-模式"><a href="#种类-x2F-模式" class="headerlink" title="种类&#x2F;模式"></a>种类&#x2F;模式</h2><table>
<thead>
<tr>
<th>种类</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>null</code></td>
<td>不传递或 null 或 undefined，表示同步执行</td>
</tr>
<tr>
<td><code>queue</code></td>
<td>使用队列的方式执行</td>
</tr>
<tr>
<td><code>asap</code></td>
<td>全称：as soon as possible ，表示尽快执行</td>
</tr>
<tr>
<td><code>async</code></td>
<td>使用   <code>setInterval</code>   的调度。</td>
</tr>
</tbody></table>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>下面我们举例略窥一下各个模式的表现。</p>
<h3 id="null-x2F-undefined-x2F-sync"><a href="#null-x2F-undefined-x2F-sync" class="headerlink" title="null&#x2F;undefined&#x2F;sync"></a>null&#x2F;undefined&#x2F;sync</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import &#123; asapScheduler, asyncScheduler, from &#125; from &#x27;rxjs&#x27;;</span><br><span class="line">function syncSchedulerMain() &#123;</span><br><span class="line">    console.log(&#x27;before&#x27;);</span><br><span class="line">    from([1, 2, 3]).subscribe(console.log)</span><br><span class="line">    console.log(&#x27;after&#x27;);</span><br><span class="line">&#125;</span><br><span class="line">syncSchedulerMain();</span><br><span class="line">// 执行结果：</span><br><span class="line">// before</span><br><span class="line">// 1</span><br><span class="line">// 2</span><br><span class="line">// 3</span><br><span class="line">// after</span><br></pre></td></tr></table></figure>

<h3 id="asap"><a href="#asap" class="headerlink" title="asap"></a>asap</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function asyncSchedulerMain() &#123;</span><br><span class="line">    console.log(&#x27;asyncScheduler: before&#x27;);</span><br><span class="line">    from([1, 2], asyncScheduler).subscribe(console.log)</span><br><span class="line">    Promise.resolve(&#x27;asyncScheduler: promise&#x27;).then(console.log);</span><br><span class="line">    console.log(&#x27;asyncScheduler: after&#x27;);</span><br><span class="line">&#125;</span><br><span class="line">// 执行结果：</span><br><span class="line">// asapScheduler: before</span><br><span class="line">// asapScheduler: after</span><br><span class="line">// 1</span><br><span class="line">// 2</span><br><span class="line">// asapScheduler: promise</span><br></pre></td></tr></table></figure>

<p>从结果示，from 的数据的输出顺序是  <strong>在 console.log（同步代码）之后，promise.then 之前的</strong>  。</p>
<h3 id="async"><a href="#async" class="headerlink" title="async"></a>async</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function asapSchedulerMain() &#123;</span><br><span class="line">    console.log(&#x27;asapScheduler: before&#x27;);</span><br><span class="line">    from([1, 2, 3], asapScheduler).subscribe(console.log)</span><br><span class="line">    Promise.resolve(&#x27;asapScheduler: promise&#x27;).then(console.log);</span><br><span class="line">    console.log(&#x27;asapScheduler: after&#x27;);</span><br><span class="line">&#125;</span><br><span class="line">// 执行结果：</span><br><span class="line">// asyncScheduler: before</span><br><span class="line">// asyncScheduler: after</span><br><span class="line">// asyncScheduler: promise</span><br><span class="line">// 1</span><br><span class="line">// 2</span><br></pre></td></tr></table></figure>

<p>结果示，  <strong>from 数据输出顺序是在 console.log（同步代码）和 Promise.then 之后的</strong>  。</p>
<h2 id="工作原理-2"><a href="#工作原理-2" class="headerlink" title="工作原理"></a>工作原理</h2><p>Scheduler 工作原理可以类比 JS 中的调用栈和事件循环，从实现上   <code>aspa</code>  和   <code>async</code>  也的确交给事件循环来处理。  <code>null /undefined</code>  相当于调用栈，  <code>aspa</code>  相当于事件循环中的微任务，  <code>async</code>  相当于宏任务，可以肯定的是微任务执行时机的优先级比宏任务要高，所以从执行时机来看 null &gt; aspa &gt; async。  <code>queue</code>  运行模式根据 delay 的参数来决定，如果是 0，那么就用同步的方式执行，如果大于 0，就以 async 模式执行。</p>
<p><img src="https://atlas-rc.pingcode.com/files/public/6305a0fbaae45a607c40301b/origin-url" alt="image.png"></p>
<h2 id="使用原则-x2F-策略"><a href="#使用原则-x2F-策略" class="headerlink" title="使用原则&#x2F;策略"></a>使用原则&#x2F;策略</h2><p>RxJS Scheduler 的原则是：尽量减少并发运行。</p>
<ol>
<li>对于返回有限和少量消息的 observable 的操作符，RxJS 不使用调度器，即   <code>null</code>   或   <code>undefined</code>   。</li>
<li>对于返回潜在大量的或无限数量的消息的操作符，使用   <code>queue</code>   调度器。</li>
<li>对于使用定时器的操作符，使用   <code>aysnc</code>   调度器。</li>
</ol>
<h2 id="支持调度器的操作符"><a href="#支持调度器的操作符" class="headerlink" title="支持调度器的操作符"></a>支持调度器的操作符</h2><p>  <code>of</code>  、  <code>from</code>  、  <code>timer</code>  、  <code>interval</code>  、  <code>concat</code>  、  <code>merge</code>  、  <code>combineLatest</code>  ，更多戳  <a href="https://cn.rx.js.org/manual/overview.html#h17">这里。</a>  </p>
<p>  <code>bufferTime</code>  、  <code>debounceTime</code>  、  <code>delay</code>  、  <code>auditTime</code>  、  <code>sampleTime</code>  、  <code>throttleTime</code>  、  <code>timeInterval</code>  、  <code>timeout</code>  、  <code>timeoutWith</code>  、  <code>windowTime</code>   这样时间相关的操作符全部接收调度器作为最后的参数，并且默认的操作是在   <code>Scheduler.async</code>   调度器上。</p>
<p>OK，关于调度器我们先了解到这里。</p>
<h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>至此，RxJS 内容已经讲解完毕，文中概念较多，若大家都能够理解，就可以对 RxJS 的认知拉到同一个维度，后续需要做的就是玩转各种操作符，解决实际问题，学以致用才可达到真正的精通。</p>
<p>最后如果觉得文章不错，点个赞再走吧！</p>
<p>附文中完整代码与示例：  <a href="https://github.com/aaaaaajie/simple-rxjs">https://github.com/aaaaaajie/simple-rxjs</a>  </p>
<h1 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h1><ul>
<li><a href="https://zhuanlan.zhihu.com/p/543483225">玩转 RxJS 操作符 ——流程控制篇</a>  </li>
<li><a href="https://zhuanlan.zhihu.com/p/553188292">玩转 RxJS 操作符——回压控制篇</a></li>
</ul>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="https://www.reactivemanifesto.org/zh-CN">反应式宣言</a>  </li>
<li><a href="https://cn.rx.js.org/">RxJS 中文文档</a>  </li>
<li><a href="https://reactivex.io/intro.html">Reactive X 文档</a>  </li>
<li><a href="https://robin-front.github.io/RxJS-doc-chinese/">RxJS 入门指南</a>  </li>
<li><a href="https://juejin.cn/post/6910943445569765384">RxJS 给你丝滑般的编程体验</a>  </li>
<li><a href="https://stackoverflow.com/questions/47537934/what-is-the-difference-between-observable-and-a-subject-in-rxjs">Observable vs Subject</a>  </li>
<li>《RxJS 深入浅出》——程墨</li>
</ul>
<h2 id="-1"><a href="#-1" class="headerlink" title=""></a></h2>]]></content>
      <categories>
        <category>RxJS</category>
      </categories>
  </entry>
  <entry>
    <title>Git 常用命令</title>
    <url>/2023/02/03/git%E6%89%8B%E5%86%8C/</url>
    <content><![CDATA[<h2 id="打-tag"><a href="#打-tag" class="headerlink" title="打 tag"></a>打 tag</h2><ul>
<li>快速打标签: <code>git tag 名字</code></li>
<li>推送至远程: <code>git push origin 标签名</code></li>
</ul>
]]></content>
      <categories>
        <category>git</category>
      </categories>
  </entry>
  <entry>
    <title>centos7安装yum</title>
    <url>/2023/02/03/centos7%E5%AE%89%E8%A3%85yum/</url>
    <content><![CDATA[<p>一般购买的服务器都自带 yum，但恰好我买的这台就没有，WTF…</p>
<h2 id="一、创建安装目录"><a href="#一、创建安装目录" class="headerlink" title="一、创建安装目录"></a>一、创建安装目录</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /usr</span><br><span class="line">mkdir yum-install</span><br><span class="line">cd yum-install</span><br></pre></td></tr></table></figure>

<h2 id="二、wget-下载所有需要的-package"><a href="#二、wget-下载所有需要的-package" class="headerlink" title="二、wget 下载所有需要的 package"></a>二、wget 下载所有需要的 package</h2><p>在安装yum之前需要安装的依赖包</p>
<ul>
<li>python-iniparse-0.4-9.el7.noarch.rpm</li>
<li>yum-metadata-parser-1.1.4-10.el7.x86_64.rpm</li>
<li>yum-3.4.3-168.el7.centos.noarch.rpm</li>
<li>yum-plugin-fastestmirror-1.1.31-54.el7_8.noarch.rpm</li>
</ul>
<p>具体package的仓储： <a href="http://mirrors.163.com/centos/7/os/x86_64/Packages/">http://mirrors.163.com/centos/7/os/x86_64/Packages/</a> </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget http://mirrors.163.com/centos/7/os/x86_64/Packages/python-iniparse-0.4-9.el7.noarch.rpm</span><br><span class="line">wget http://mirrors.163.com/centos/7/os/x86_64/Packages/yum-metadata-parser-1.1.4-10.el7.x86_64.rpm</span><br><span class="line">wget http://mirrors.163.com/centos/7/os/x86_64/Packages/yum-3.4.3-168.el7.centos.noarch.rpm</span><br><span class="line">wget http://mirrors.163.com/centos/7/os/x86_64/Packages/yum-plugin-fastestmirror-1.1.31-54.el7_8.noarch.rpm</span><br></pre></td></tr></table></figure>

<h2 id="三、rpm-安装"><a href="#三、rpm-安装" class="headerlink" title="三、rpm 安装"></a>三、rpm 安装</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rpm -ivh --force --nodeps python-iniparse-0.4-9.el7.noarch.rpm</span><br><span class="line">rpm -ivh --force --nodeps yum-metadata-parser-1.1.4-10.el7.x86_64.rpm</span><br><span class="line">rpm -ivh --force --nodeps yum-3.4.3-168.el7.centos.noarch.rpm</span><br><span class="line">rpm -ivh --force --nodeps yum-plugin-fastestmirror-1.1.31-54.el7_8.noarch.rpm</span><br></pre></td></tr></table></figure>
<h2 id="四、安装-yum"><a href="#四、安装-yum" class="headerlink" title="四、安装 yum"></a>四、安装 yum</h2><p>包地址： <a href="http://yum.baseurl.org/wiki.html">http://yum.baseurl.org/wiki.html</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wget http://yum.baseurl.org/download/3.4/yum-3.4.3.tar.gz</span><br></pre></td></tr></table></figure>

<h2 id="五、测试"><a href="#五、测试" class="headerlink" title="五、测试"></a>五、测试</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum --help</span><br></pre></td></tr></table></figure>
<p>能出来命令，说明安装成功！</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p> <a href="https://cloud.tencent.com/developer/article/1720868">https://cloud.tencent.com/developer/article/1720868</a> <br>⚠️ 注意：上面博客里面的有些包已经升级了，推荐使用本文的链接或官方的链接寻找资源</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>hexo ocean 主题集成 mermaid</title>
    <url>/2023/02/08/mermaid/</url>
    <content><![CDATA[<p>mermaid 是一款可以使用文本来绘图的工具，支持流程图、时序图、类图、饼状图等等，更多看<a href="https://mermaid.js.org/intro/">这里</a>。它可以支持在 markdown 中使用，这对于我这种程序员非常的好用，可以代替一些插图，hexo 对插图是一大痛点（上传图片，然后在 markdown 中插入链接，重要的是要考虑储存位置、空间和后期的维护），本人习惯使用代码块或文字的方式代替，所以这是一篇 hexo ocean 集成 mermaid 的文档。</p>
<span id="more"></span>
<p>先做个展示如下</p>
<pre class="mermaid">flowchart LR
    A[Start] --> B{Is it?}
    B -->|Yes| C[OK]
    C --> D[Rethink]
    D --> B
    B ---->|No| E[End]</pre>

<h2 id="方式一：远程加载-mermaid"><a href="#方式一：远程加载-mermaid" class="headerlink" title="方式一：远程加载 mermaid"></a>方式一：远程加载 mermaid</h2><ol>
<li>添加配置<br>到 themes&#x2F;ocean 的 _config.yml 文件中添加以下配置<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mermaid: </span><br><span class="line">  enable: true</span><br><span class="line">  version: &quot;9.0.0&quot; # 远程加载</span><br></pre></td></tr></table></figure></li>
<li>到 themes&#x2F;ocean&#x2F;layout 的 post.ejs 文件添加以下代码<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;section <span class="keyword">class</span>=<span class="string">&quot;outer&quot;</span>&gt;</span><br><span class="line">  &lt;%- <span class="title function_">partial</span>(<span class="string">&#x27;_partial/article&#x27;</span>, &#123;<span class="attr">post</span>: page, <span class="attr">index</span>: <span class="literal">false</span>&#125;) %&gt;</span><br><span class="line">  &lt;% <span class="keyword">if</span> (theme.<span class="property">mermaid</span>.<span class="property">enable</span>) &#123; %&gt;</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&#x27;https://unpkg.com/mermaid@&lt;%= theme.mermaid.version %&gt;/dist/mermaid.min.js&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="keyword">if</span> (<span class="variable language_">window</span>.<span class="property">mermaid</span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        mermaid.<span class="title function_">initialize</span>(&#123;<span class="attr">theme</span>: <span class="string">&#x27;forest&#x27;</span>&#125;);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">  &lt;% &#125; %&gt;</span><br><span class="line">&lt;/section&gt;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="方式二：本地加载-marmaid（推荐）"><a href="#方式二：本地加载-marmaid（推荐）" class="headerlink" title="方式二：本地加载 marmaid（推荐）"></a>方式二：本地加载 marmaid（推荐）</h2><p>本地加载 js 比远程访问速度快，所以推荐。配置跟第一种差不多，只是源码文件下载到本地。</p>
<ol>
<li><p>添加配置<br>到 themes&#x2F;ocean 的 _config.yml 文件中添加以下配置</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mermaid: </span><br><span class="line">  enable: true</span><br></pre></td></tr></table></figure>
</li>
<li><p>下载 mermaid 源码，@后面的是版本，可以挑选自己想要的版本，版本信息看<a href="https://github.com/mermaid-js/mermaid">这里</a><br>地址：<a href="https://unpkg.com/mermaid@9.0.0/dist/mermaid.min.js">https://unpkg.com/mermaid@9.0.0/dist/mermaid.min.js</a><br>下载后放到 themes&#x2F;ocean&#x2F;source&#x2F;js 目录下，文件名可以叫做 mermaid.min.js，名字可以自定义。</p>
</li>
<li><p>进入 themes&#x2F;ocean&#x2F;layout&#x2F;_partial 目录找到 after-footer.ejs 加入以下代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;% <span class="keyword">if</span> (theme.<span class="property">mermaid</span>.<span class="property">enable</span>) &#123; %&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&#x27;/js/mermaid.min.js&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">if</span> (<span class="variable language_">window</span>.<span class="property">mermaid</span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      mermaid.<span class="title function_">initialize</span>(&#123;<span class="attr">theme</span>: <span class="string">&#x27;forest&#x27;</span>&#125;);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">&lt;% &#125; %&gt;</span><br></pre></td></tr></table></figure></li>
</ol>
<p> OK，到此配置结束。</p>
<p>参考：<a href="https://github.com/webappdevelp/hexo-filter-mermaid-diagrams">https://github.com/webappdevelp/hexo-filter-mermaid-diagrams</a></p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
  </entry>
  <entry>
    <title>Mongodb 常用 API</title>
    <url>/2023/02/01/mongodb%E6%89%8B%E5%86%8C/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Mongodb</category>
      </categories>
  </entry>
  <entry>
    <title>谈面向切面编程—AOP</title>
    <url>/2023/02/07/%E5%88%87%E9%9D%A2%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<p>第一次听说 AOP 这个概念大概还是在 5 年前，那时还是一个 Java 小白，只赚了个耳熟，这些年倒比较理解了，但并没有好好总结一篇，最近又看到相关话题，大家存在分歧有些争论，都多少有些片面，这里个人也大言不惭，谈一下 AOP。</p>
<span id="more"></span>
<h2 id="什么是-AOP"><a href="#什么是-AOP" class="headerlink" title="什么是 AOP"></a>什么是 AOP</h2><p>AOP 为 Aspect Oriented Programming 的缩写，意为：面向切面编程，是一种把系统分为多个关注点（切面）解决问题的思维。</p>
<p>有很多资料说 AOP 是 OOP 的补充，而个人认为此观点有些局限，对面向对象语言工作者来说，OOP 是把系统当作多个对象之间的交互，AOP 把这些分解成不同关注点，帮助解决了问题，然而 AOP 不光只针对 OOP 来讲的，同样面向过程编程有些短板也可以用 AOP 来补充的，所以我们应该明确的观点是 AOP 是独立于其他编程模式之外的，不只是某一种编程模式的补充。</p>
<blockquote>
<p>AOP 产生于 1997 年的欧洲面向对象编程大会（ECO0P97）上，施乐公司 PaloAlto 研究中心首席科学家、大不列颠哥伦比亚大学教授 GregorKiczales 等人首次提出了 AOP 的概念，此后每年的 ECOOP 上都有AOP相关的专题研讨会，各大公司、大学、研究机构纷纷投入人员进行研究。2001 年 3 月 15 日，PaloAlto 研究中心发布了首种支持 AOP 的语言，AspectJ。</p>
</blockquote>
<h2 id="AOP-核心思想"><a href="#AOP-核心思想" class="headerlink" title="AOP 核心思想"></a>AOP 核心思想</h2><h3 id="什么是切面（Aspect）"><a href="#什么是切面（Aspect）" class="headerlink" title="什么是切面（Aspect）"></a>什么是切面（Aspect）</h3><p>AOP 最重要的关键词是 Aspect（切面），所谓的 Aspect，从设计上讲，是横切系统的关注点，这里又产生了一个新名词“横切”，为什么不是竖切？<strong>从历史来讲，传统的面向过程和面向对象中的继承都是自顶向下的编程范式</strong>，例如：</p>
<pre class="mermaid">graph TD;
    出门-->看电影;
    看电影-->回家;
    接收请求-->业务逻辑;
    业务逻辑-->响应;
    爷-->父;
    父-->子;
    人--> 黄种人;
    黄种人--> 中国人;</pre>
<p>拿服务端处理请求的逻辑来讲，有 n 个请求，都要走<strong>接收请求-&gt;处理业务逻辑-&gt;响应</strong>这样的逻辑，这里面必然有很多的其他环节，比如<strong>每个请求验证登录状态，在业务逻辑前后加日志显示耗时</strong>……</p>
<pre class="mermaid">flowchart TB
    req1(接收请求)-->state1(验证登录状态)-->logic1(业务逻辑)-->log1(日志显示耗时)-->res1(响应);
    req2(接收请求)-->state2(验证登录状态)-->logic2(业务逻辑)-->log2(日志显示耗时)-->res2(响应);
    req3(接收请求)-->state3(验证登录状态)-->logic3(业务逻辑)-->log3(日志显示耗时)-->res3(响应);
    reqn(接收请求)-->staten(验证登录状态)-->logicn(业务逻辑)-->logn(日志显示耗时)-->resn(响应);

    state1-.-state2-.-state3-.-staten;

    log1-.-log2-.-log3-.-logn;

    style state1 fill:#bbf,stroke:#f66,stroke-width:2px,color:#fff,stroke-dasharray: 5 5;
    style state2 fill:#bbf,stroke:#f66,stroke-width:2px,color:#fff,stroke-dasharray: 5 5;
    style state3 fill:#bbf,stroke:#f66,stroke-width:2px,color:#fff,stroke-dasharray: 5 5;
    style staten fill:#bbf,stroke:#f66,stroke-width:2px,color:#fff,stroke-dasharray: 5 5;
    
    style log1 fill:#bbf,stroke:#f66,stroke-width:2px,color:#fff,stroke-dasharray: 5 5;
    style log2 fill:#bbf,stroke:#f66,stroke-width:2px,color:#fff,stroke-dasharray: 5 5;
    style log3 fill:#bbf,stroke:#f66,stroke-width:2px,color:#fff,stroke-dasharray: 5 5;
    style logn fill:#bbf,stroke:#f66,stroke-width:2px,color:#fff,stroke-dasharray: 5 5;</pre>
<p>遇到这种情况时，一种是比较简单，在每个过程前后都写一遍上述逻辑，或者复制粘贴，但这依旧显得有些“蠢笨”，而且后期维护也是个大问题，所以<strong>正确的思路是提取出来此逻辑</strong>，然后在需要的地方动态注入此逻辑，这个做法在如今已经是很常见的了，大家也在大多数场景下形成了这种意识，而这个切点就是“验证登录状态”、“写日志”，多个切点（虚线）连接的面独立于纵向程序之外形成横切面。</p>
<h3 id="代码联结"><a href="#代码联结" class="headerlink" title="代码联结"></a>代码联结</h3><blockquote>
<p>代码联结是指对输入的组件语言和 aspect ，根据联结点的语法定义，生成相应的中间文件或目标代码。这个过程可以分成三个阶段进行。首先，为组件语言和 Aspect 语言构造相应的语法树；然后依据 aspect 中的联结点定义对语法树进行联结；最后在联结的语法树上生成中间文件或目标代码。</p>
</blockquote>
<p>这段资料比较官方，个人的理解就是独立于模块外的中间目录&#x2F;文件&#x2F;代码。</p>
<h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><p>衡量软件质量高低的要素主要包括可靠性、可扩展性、可重用性、兼容性以及易用性和易维护性等。其中 <strong>AOP 体现了可扩展性、可重用性和易理解性、易维护性等方面的能力</strong>，拿上面的例子对应这些特性体现之处：</p>
<ol>
<li>可扩展性：面向系统级的扩展，在任何需要打日志的地方注入此逻辑，如果是面向对象那么只能是类级别的继承使用此逻辑。</li>
<li>可重用性：这点最直观，减去写多遍具体的实现逻辑，提取到全局通用，只需要在不同的地方去<strong>注入</strong>。</li>
<li>易理解性：减少代码缠结的问题，抽象于程序之外，专注于程序逻辑。</li>
<li>易维护性：当验证登录状态的逻辑发生变化时，通过联结器影响到系统相关的各个部分，只需要改动一处，避免漏掉。<br>基于以上特性达到松耦合、易于维护和扩展的目的。</li>
</ol>
<h2 id="实现手段"><a href="#实现手段" class="headerlink" title="实现手段"></a>实现手段</h2><ul>
<li>代理</li>
<li>反射注入（DI）</li>
</ul>
<h2 id="常用场景"><a href="#常用场景" class="headerlink" title="常用场景"></a>常用场景</h2><ul>
<li>拦截器：服务端路由中间件、前端路由守卫</li>
<li>依赖注入</li>
<li>日志</li>
<li>错误处理</li>
<li>前端管道</li>
<li>消息队列</li>
</ul>
<p>如果有人浏览到此文章有不同意见，欢迎留言！</p>
]]></content>
      <categories>
        <category>编程思想</category>
      </categories>
  </entry>
  <entry>
    <title>新启程——开篇</title>
    <url>/2023/01/17/%E5%BC%80%E7%AF%87/</url>
    <content><![CDATA[<blockquote>
<p>今天是 2023-01-18，农历壬寅年腊月廿七（2022 年 12 月 27），此时是年前的摸鱼时刻 😂 </p>
</blockquote>
<p>有人说，一个人的成长就是趋于稳定，比如，不再频繁的换手机号码、换工作、换房子……那写作的博客平台何尝不是呢？回头看下，自己已经用了许许多多的博客平台：CSDN、简书、语雀、掘金、知乎、思否、InfoQ、还有我们的 PingCode Wiki，还使用过 Hexo 搭了一套博客，甚至还用 Vue + NodeJS 原生写了一个博客系统，最终还一直在用&#x2F;维护的只剩下了知乎和 Wiki 吧，至于其它的都是以这样或那样的原因最终放弃。</p>
<p>有了这么多平台为什么还要再整一个 github pages 的个人博客呢？</p>
<p>一个重要的原因是，前段时间服务器到期了，几百篇笔记都没有备份上，妈蛋！所以不想自己维护了，github pages 倒不用担心这点，就是访问稍慢，还算是可以接受吧。为啥不用 gitee pages？因为要备案，上传身份证和手持，当天没有带身份证，也懒得再操心这事了。</p>
<p>这个博客作为自己的思源地，同时也记录一些有深度的文章，也可能转载一些之前在其他平台写过的笔记&#x2F;文章，无论怎样，开启新篇章吧，希望自己多做些笔记，多些思考，多些沉淀！</p>
]]></content>
  </entry>
  <entry>
    <title>论读书</title>
    <url>/2023/01/17/%E6%80%8E%E4%B9%88%E6%89%8D%E7%AE%97%E4%B8%80%E6%9C%AC%E5%A5%BD%E4%B9%A6/</url>
    <content><![CDATA[<blockquote>
<p> 怎么算一本好书</p>
</blockquote>
<p>自从看了一本《沧浪之水》的书之后就有点入迷小说类的书了，家里的书也不算少，但最近能找到自己看得上眼的书，基本没有（《人类简史》勉强算是），其他书并非不好，只是不符合自己的标准。所有有时自己就会想，什么样的书才算称得上是好书？自己心里的标准是啥样的？</p>
<p>针对书架上现有的书做个分类，也大致说下标准：</p>
<span id="more"></span>

<ol>
<li>工具类的书，通常  <strong>这类书字字珠玑，均是干货</strong>  ，这种书对  <strong>知识的准确性必须过关</strong>  ，否则难以称得上好书。例如字典、文档、手册之类的，如大犀牛《Javascript 权威指南》、《说文解字》。</li>
<li>理论类的书，这类书往往是富含真理，  <strong>有理论，有实践示例</strong>  可称得上好书。如《代码整洁之道》。</li>
<li>哲理类的书，这类的书往往是人生前行路上的路灯，  <strong>能说明问题，并且对接下来行动产生指导价值的算得上好书，但有一条原则是正能量</strong>  ，心灵毒鸡汤的书不可算。如《道德经》、《素书》、《王阳明心学》。</li>
<li>小说类的书，这类书主要是以故事情节表达出真理，让读者自己感悟和体会，往往引人发省，个人感觉跟哲理类的书的标准差不多，  <strong>评判标准包含上条（哲理类），还有一条是能够吸引读者，令人回味，</strong>  网文玄幻花里胡哨的且不论，如《钢铁是怎样炼成的》、《平凡的世界》、《人生》、《沧浪之水》、《瓦尔登湖》。</li>
<li>议论文的书，这类书的作者能够站在现如今已产生的哲理或现象，  <strong>表达出独特的观点，观点能得到大部分人认可的可称得上是好书</strong>  。如《容忍与自由》、《人类简史》。</li>
<li>科普类的书，这类书  <strong>只需要描述出已存在的事实、道理或知识即可</strong>  ，不一定必须深入。如历史书《历代皇帝大全》、《中国历史故事》。</li>
<li>人物传记类，通过人物的事迹和思想表达成功的原因，  <strong>能应用到现实中</strong>  的可为好书。当然，出于兴趣乐呵除外。如《为什么是毛泽东》。</li>
</ol>
<p>太过硬核&#x2F;干货的书直接排除，因为工作完会累，脑子会拒绝；自控力差枯燥，脑子会拒绝，所以符合自己标准基本算是小说了，大概有这么几条：</p>
<ol>
<li>情节吸引人。</li>
<li>符合如今社会，能对接下来的人生带来指导原则。</li>
<li>触及内心情感，令人发省。</li>
</ol>
<p>能全部符合三条的小说不多，尤其是第二条，所以上知乎 Up 主推荐的那些书，从书评中并没有特别符合标准的，例如著名小说，有些还曾获得诺贝尔文学奖，矛盾文学奖的：《活着》、《平凡的世界》等，反正一时想不起来那么多了……。</p>
<p>最近，买了一本《约翰·克里斯多夫》的小说，大概说是这个人的传奇人生，净化心灵等，这本书足够长，可以消遣一阵子了，希望这本书不会让自己失望    </p>
]]></content>
      <categories>
        <category>读书感悟</category>
      </categories>
  </entry>
  <entry>
    <title>批量删除本地分支</title>
    <url>/2023/02/03/%E6%89%B9%E9%87%8F%E5%88%A0%E9%99%A4%E6%9C%AC%E5%9C%B0%E5%88%86%E6%94%AF/</url>
    <content><![CDATA[<h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git branch | grep -v &#x27;develop&#x27; | xargs git branch -D</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h2 id=""><a href="#" class="headerlink" title="|"></a>|</h2><p>管道命令，用于将一串命令串联起来。前面命令的输出可以作为后面命令的输入。</p>
<h2 id="git-branch"><a href="#git-branch" class="headerlink" title="git branch"></a>git branch</h2><p>用于列出本地所有分支。</p>
<h2 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h2><p>搜索过滤命令。使用正则表达式搜索文本，并把匹配的行打印出来。</p>
<h2 id="xargs"><a href="#xargs" class="headerlink" title="xargs"></a>xargs</h2><p>参数传递命令。用于将标准输入作为命令的参数传给下一个命令。</p>
<p>参考<br>grep： <a href="https://wangchujiang.com/linux-command/c/grep.html">https://wangchujiang.com/linux-command/c/grep.html</a> <br>xargs： <a href="https://wangchujiang.com/linux-command/c/xargs.html">https://wangchujiang.com/linux-command/c/xargs.html</a> </p>
]]></content>
      <categories>
        <category>git</category>
      </categories>
  </entry>
  <entry>
    <title>编程角度谈抽象</title>
    <url>/2023/01/18/%E7%BC%96%E7%A8%8B%E8%A7%92%E5%BA%A6%E8%B0%88%E6%8A%BD%E8%B1%A1/</url>
    <content><![CDATA[<h4 id="什么是抽象？"><a href="#什么是抽象？" class="headerlink" title="什么是抽象？"></a>什么是抽象？</h4><p>抽象就是从不同的事物之间抽取出相同点。往往能力越强，抽象能力就越强，认知的维度就越高。</p>
<span id="more"></span>

<h4 id="为什么要抽象？"><a href="#为什么要抽象？" class="headerlink" title="为什么要抽象？"></a>为什么要抽象？</h4><p>世间万物都在变化，如果具有了抽象能力，在变化中找到不变，那么在解决问题中只需要更改那些需要变化的元素，从而减少工作量。</p>
<p>例如，软件开发中的需求不断变化。有人说，杀死一个程序员，不是给他一把刀，而只需要改3次需求。程序员设计程序时，能够把这些变化的需求和不变的本质分析出来，设计出相对抽象的程序，选择适当的数据结构和设计模式，来进行对可变的元素进行重写而不用改其他依赖，那么是否能避免一部分全部推倒重来的事情发生呢？</p>
<h4 id="抽象的应用或表现"><a href="#抽象的应用或表现" class="headerlink" title="抽象的应用或表现"></a>抽象的应用或表现</h4><p>软件工程学中OOAD(objectorientanalysisdesign)，软件编程思想中的OOP(objectorientprogram)。<br>他们的第一要素都是抽象，抽象的维度越合适，设计的程序就越易用。</p>
<p>例如，一个小超市要做一款对商品的管理系统，商品暂时只有白酒。</p>
<p>程序员A针对<strong>白酒</strong>进行分析了属性并设计了一个白酒类</p>
<p>程序员B针对<strong>酒</strong>分析属性设计了一个酒类并加入了<strong>type</strong>属性来区分白酒或其他类型的酒。</p>
<p>程序员C针对<strong>饮品</strong>分析属性设计了一个饮品类加入了<strong>type</strong>区分是酒还是其他饮品，并将原来的type变为<strong>color，</strong>只有是type是酒的时候才拥有color属性。</p>
<p>程序员D针对<strong>商品</strong>分析了属性设计了商品类加入了商品类型<strong>type</strong>区分是饮品还是其他商品，将C的type变为drinkType，只有type是饮品的时候才拥有drinkType属性。</p>
<p>later……，超市挣钱了变成了大超市，不仅卖白酒也开始卖啤酒和红酒了，那么程序员A的程序设计的程序很遗憾的就被淘汰了！</p>
<p>又later……，超市继续扩大，不仅卖酒，而且开始卖奶，矿泉水，饮料等饮品，程序员B设计的程序淘汰！<br>又又later……，不仅卖饮品，还卖起了水果，日用品，程序员C设计的程序淘汰！</p>
<p>从上面的例子中就可以看到，程序员D的程序最棒，因为他抽象的层级比其他三个都要高，所以面对变化也可以从容应对，调整不会太大！</p>
<h4 id="抽象的维度越高越好吗？"><a href="#抽象的维度越高越好吗？" class="headerlink" title="抽象的维度越高越好吗？"></a>抽象的维度越高越好吗？</h4><p>这个要根据场景选择合适的抽象维度，并不完全是越抽象越好，因为抽象最终要应用到使用，使用必然要具体，要找具体，步骤就会<strong>繁琐</strong>，会<strong>增加复杂度。</strong></p>
<p>从上面的例子中来说，超市老板的需求最大就是超市可以满足的特征，衣食、日用等商品，他不可能超市卖所有种类东西，不然世界就是这个老板的了，如果程序员的抽象维度是商品(非上面商品)，那么他就要包括其他类型商品：飞机、大炮、汽车、绣花针等，程序员就要分n种类型，那么他这个程序要操作一个商品需要检查n个层级才能找到对应的商品，程序会很慢甚至超出等待，过几天老板就不用这个系统了，因为还没有自己找的快呢！</p>
<p>所以，抽象能力是必不可少的，抽象能力越高说明你站的角度越高，思考的就越高，这在你的生活和工作当中很有帮助！不然孔子，老子这样的人能够成为大智者呢，老子的道你又是否懂呢？</p>
]]></content>
      <categories>
        <category>思源地</category>
      </categories>
  </entry>
  <entry>
    <title>一剑，一念</title>
    <url>/2023/02/06/%E9%9D%A2%E5%AF%B9%E7%96%BE%E9%A3%8E%E5%90%A7/</url>
    <content><![CDATA[<p>个人优势：</p>
<ul>
<li>善于总结和独立思考</li>
<li>对技术保持持续热情</li>
<li>敢于挑战和突破自己</li>
</ul>
<p>专业技能：</p>
<ul>
<li>掌握并灵活运用常用编程思想及设计模式解决问题：面向对象编程（OOP）、切面编程（AOP）、响应式编程（RX）、函数式编程（FP）、代理（Proxy）</li>
<li>灵活运用 TypeScript 类型及相关技术：装饰器实现依赖注入、面向接口约束行为</li>
<li>掌握 NodeJS 框架 Express、KOA、Chaos（公司自研，类似于 Next），并看过其源码，深刻理解中间件机制</li>
<li>掌握前端框架 Angular 及相关生态：RxJS、CDK 等</li>
<li>熟练使用 MongoDB、Redis、MySQL 等缓存技术</li>
<li>了解微前端、后端微服务、分布式集群</li>
</ul>
<p>工作职责：</p>
<ul>
<li>负责 Wiki 架构设计及核心功能模块开发</li>
<li>与产品经理，设计师配合探讨、设计、实现产品的核心功能迭代及改进</li>
<li>负责核心模块代码编写，并对功能模块进行单元测试的编写</li>
<li>对前后端代码结构和性能进行持续优化</li>
</ul>
]]></content>
  </entry>
</search>
